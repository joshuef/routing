// Copyright 2020 MaidSafe.net limited.
//
// This SAFE Network Software is licensed to you under The General Public License (GPL), version 3.
// Unless required by applicable law or agreed to in writing, the SAFE Network Software distributed
// under the GPL Licence is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. Please review the Licences for the specific language governing
// permissions and limitations relating to use of the SAFE Network Software.

use crate::{
    event::Event,
    location::{DstLocation, SrcLocation},
    messages::{Message, Variant},
    node::stage::Stage,
};
use bytes::Bytes;
use futures::lock::Mutex;
use quic_p2p::{IncomingConnections, IncomingMessages, Message as QuicP2pMsg};
use std::{net::SocketAddr, sync::Arc};
use tokio::sync::mpsc;
use xor_name::XorName;

// Maximum number of events to be buffered internally, when the buffer is full
// no new events can be generated by this crate, even if external messages
// coming from other peers need to be rejected.
const MAX_EVENTS_BUFFERED: usize = 1024;

/// Stream of routing node events
pub struct EventStream {
    events_rx: mpsc::Receiver<(Option<Event>, Option<(SocketAddr, Message)>)>,
    stage: Arc<Mutex<Stage>>,
}

impl EventStream {
    pub(crate) fn new(
        stage: Arc<Mutex<Stage>>,
        incoming_conns: IncomingConnections,
        xorname: XorName,
    ) -> Self {
        // TODO: remove the bool and define a type which signals if the
        // event needs to be processed by us or simply relay it
        let (events_tx, events_rx) =
            mpsc::channel::<(Option<Event>, Option<(SocketAddr, Message)>)>(MAX_EVENTS_BUFFERED);
        Self::spawn_connections_handler(events_tx, incoming_conns, xorname);

        Self { events_rx, stage }
    }

    /// Returns next event
    pub async fn next(&mut self) -> Option<Event> {
        while let Some((relay_event, msg)) = self.events_rx.recv().await {
            // Shall we just relay the event?
            if relay_event.is_some() {
                info!("Relaying the event: {:?}", relay_event);
                return relay_event;
            } else if let Some((src, message)) = msg {
                // Process the message according to our stage
                let _ = self
                    .stage
                    .lock()
                    .await
                    .process_message(Some(src), message)
                    .await;
            }
        }
        None
    }

    // Spawns a task which handles each new incoming connection from peers
    fn spawn_connections_handler(
        events_tx: mpsc::Sender<(Option<Event>, Option<(SocketAddr, Message)>)>,
        mut incoming_conns: IncomingConnections,
        xorname: XorName,
    ) {
        let _ = tokio::spawn(async move {
            while let Some(incoming_msgs) = incoming_conns.next().await {
                trace!(
                    "New connection established by peer {}",
                    incoming_msgs.remote_addr()
                );
                Self::spawn_messages_handler(events_tx.clone(), incoming_msgs, xorname)
            }
        });
    }

    // Spawns a task which handles each new incoming message from a connection with a peer
    fn spawn_messages_handler(
        mut events_tx: mpsc::Sender<(Option<Event>, Option<(SocketAddr, Message)>)>,
        mut incoming_msgs: IncomingMessages,
        xorname: XorName,
    ) {
        let _ = tokio::spawn(async move {
            while let Some(msg) = incoming_msgs.next().await {
                let event = match msg {
                    QuicP2pMsg::UniStream { bytes, src } => {
                        trace!(
                            "New message ({} bytes) received on a uni-stream from: {}",
                            bytes.len(),
                            src
                        );
                        // Since it's arriving on a uni-stream we treat it as a Node
                        // message which we need to be processed by us, as well as
                        // reported to the event stream consumer.
                        handle_node_message(bytes, src).await
                    }
                    QuicP2pMsg::BiStream { bytes, src, .. } => {
                        trace!(
                            "New message ({} bytes) received on a bi-stream from: {}",
                            bytes.len(),
                            src
                        );

                        // Since it's arriving on a bi-stream we treat it as a Client
                        // message which we report directly to the event stream consumer
                        // without doing any intermediate processing.
                        let event_to_relay = Some(Event::MessageReceived {
                            content: bytes,
                            src: SrcLocation::Client(src),
                            dst: DstLocation::Node(xorname),
                        });
                        Some((event_to_relay, None))
                    }
                };

                if let Some(e) = event {
                    match events_tx.send(e).await {
                        Ok(()) => {}
                        Err(err) => {
                            trace!("ERROR reporting new Event: {:?}", err);
                        }
                    }
                }
            }
        });
    }
}

async fn handle_node_message(
    msg_bytes: Bytes,
    sender: SocketAddr,
) -> Option<(Option<Event>, Option<(SocketAddr, Message)>)> {
    match Message::from_bytes(&msg_bytes) {
        Err(error) => {
            debug!("Failed to deserialize message: {:?}", error);
            None
        }
        Ok(msg) => {
            trace!("try handle message {:?}", msg);
            let event_to_relay = if let Variant::UserMessage(bytes) = msg.variant() {
                Some(Event::MessageReceived {
                    content: bytes.clone(),
                    src: msg.src().src_location(),
                    dst: *msg.dst(),
                })
            } else {
                None
            };

            Some((event_to_relay, Some((sender, msg))))

            /*if !node.in_dst_location(msg.dst()) || msg.dst().is_section() {
                // Relay closer to the destination or broadcast to the rest of our section.
                match &mut node.stage {
                    Stage::Approved(stage) => stage.relay_message(&mut self.core, msg).await,
                    Stage::Bootstrapping(_) | Stage::Joining(_) | Stage::Terminated => Ok(()),
                }
            }*/

            //if !node.in_dst_location(msg.dst()) {
            //    return Ok(());
            //}

            // TODO: filter messages which are already handled???
            /*if self.core.msg_filter.contains_incoming(&msg) {
                trace!("not handling message - already handled: {:?}", msg);
                return Ok(());
            }*/

            /*
            match self.decide_message_status(&msg)? {
                MessageStatus::Useful => {
                    //self.core.msg_filter.insert_incoming(&msg);
                    self.handle_message(sender, msg).await
                }
                MessageStatus::Untrusted => {
                    debug!("Untrusted message from {}: {:?} ", sender, msg);
                    self.handle_untrusted_message(sender, msg).await
                }
                MessageStatus::Unknown => {
                    debug!("Unknown message from {}: {:?} ", sender, msg);
                    //self.handle_unknown_message(sender, msg).await
                    Ok(())
                }
                MessageStatus::Useless => {
                    debug!("Useless message from {}: {:?}", sender, msg);
                    Ok(())
                }
            }
            */
        }
    }
}

/*fn decide_message_status(&self, msg: &Message) -> Result<MessageStatus> {
    match &self.stage {
        Stage::Bootstrapping(stage) => stage.decide_message_status(msg),
        Stage::Joining(stage) => stage.decide_message_status(msg),
        Stage::Approved(stage) => stage.decide_message_status(self.core.id(), msg),
        Stage::Terminated => Ok(MessageStatus::Useless),
    }
}

async fn handle_message(&mut self, sender: SocketAddr, msg: Message) -> Result<()> {
    if let Stage::Approved(stage) = &mut self.stage {
        stage.update_section_knowledge(&mut self.core, &msg).await?;
    }

    Ok(())
}


async fn handle_untrusted_message(&mut self, sender: SocketAddr, msg: Message) -> Result<()> {
    match &self.stage {
        Stage::Approved(stage) => {
            stage
                .handle_untrusted_message(&mut self.core, Some(sender), msg)
                .await
        }
        Stage::Bootstrapping(_) | Stage::Joining(_) | Stage::Terminated => unreachable!(),
    }
}

async fn handle_unknown_message(&mut self, sender: SocketAddr, msg: Message) -> Result<()> {
    match &mut self.stage {
        Stage::Bootstrapping(stage) => stage.handle_unknown_message(sender, msg),
        Stage::Joining(stage) => stage.handle_unknown_message(sender, msg),
        Stage::Approved(stage) => {
            stage
                .handle_unknown_message(&mut self.core, Some(sender), msg.to_bytes())
                .await?
        }
        Stage::Terminated => (),
    }

    Ok(())
}*/
