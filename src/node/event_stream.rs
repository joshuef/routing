// Copyright 2020 MaidSafe.net limited.
//
// This SAFE Network Software is licensed to you under The General Public License (GPL), version 3.
// Unless required by applicable law or agreed to in writing, the SAFE Network Software distributed
// under the GPL Licence is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. Please review the Licences for the specific language governing
// permissions and limitations relating to use of the SAFE Network Software.

use crate::{
    event::Event,
    location::{DstLocation, SrcLocation},
};
use quic_p2p::{IncomingConnections, IncomingMessages, Message};
use tokio::sync::mpsc;

// Maximum number of events to be buffered internally, when the buffer is full
// no new events can be generated by this crate, even if external messages
// coming from other peers need to be rejected.
const MAX_EVENTS_BUFFERED: usize = 1024;

/// Stream of routing node events
pub struct EventStream {
    events_rx: mpsc::Receiver<Event>,
}

impl EventStream {
    pub(crate) fn new(incoming_conns: IncomingConnections) -> Self {
        let (events_tx, events_rx) = mpsc::channel::<Event>(MAX_EVENTS_BUFFERED);
        Self::spawn_connections_handler(events_tx, incoming_conns);

        Self { events_rx }
    }

    /// Returns next event
    pub async fn next(&mut self) -> Option<Event> {
        self.events_rx.recv().await
    }

    // Spawns a task which handles each new incoming connection from peers
    fn spawn_connections_handler(
        events_tx: mpsc::Sender<Event>,
        mut incoming_conns: IncomingConnections,
    ) {
        let _ = tokio::spawn(async move {
            while let Some(incoming_msgs) = incoming_conns.next().await {
                trace!(
                    "New connection established by peer {}",
                    incoming_msgs.remote_addr()
                );
                Self::spawn_messages_handler(events_tx.clone(), incoming_msgs)
            }
        });
    }

    // Spawns a task which handles each new incoming message from a connection with a peer
    fn spawn_messages_handler(
        mut events_tx: mpsc::Sender<Event>,
        mut incoming_msgs: IncomingMessages,
    ) {
        let _ = tokio::spawn(async move {
            while let Some(msg) = incoming_msgs.next().await {
                let (content, src) = match msg {
                    Message::UniStream { bytes, src } => {
                        trace!(
                            "New message ({} bytes) received on a uni-stream from: {}",
                            bytes.len(),
                            src
                        );
                        (bytes, src)
                    }
                    Message::BiStream { bytes, src, .. } => {
                        trace!(
                            "New message ({} bytes) received on a bi-stream from: {}",
                            bytes.len(),
                            src
                        );
                        (bytes, src)
                    }
                };

                match events_tx
                    .send(Event::MessageReceived {
                        content,
                        src: SrcLocation::Client(src),
                        dst: DstLocation::Client(src),
                    })
                    .await
                {
                    Ok(()) => {}
                    Err(err) => {
                        trace!("ERROR reporting new Event: {:?}", err);
                    }
                }
            }
        });
    }
}
